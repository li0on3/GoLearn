# Day 2: 切片(Slice)深入理解

## 学习目标
1. 理解切片的底层数据结构
2. 掌握切片的创建和操作方法
3. 理解切片的容量增长机制
4. 避免切片使用中的常见陷阱

## 概念学习

### 切片的本质
切片是对数组的抽象，包含三个要素：
- **指针(ptr)**：指向底层数组的指针
- **长度(len)**：切片中元素的数量
- **容量(cap)**：从切片起始位置到底层数组末尾的元素数量

### 切片vs数组
- 数组：长度固定，值类型
- 切片：长度可变，引用类型

### 切片的扩容机制
当切片容量不足时，Go会创建新的底层数组并复制数据。扩容策略：
- 当容量小于1024时，容量翻倍
- 当容量大于等于1024时，增长25%

## 实践任务

### 任务1：切片基础操作
在 `exercises/01-basics/day02/` 创建 `slice_basics.go`

实现以下功能：
1. 用三种方式创建切片
2. 实现一个函数，打印切片的长度、容量和底层数组地址
3. 演示切片的追加操作，观察容量变化

要求：
- 每次操作后打印切片信息
- 解释容量变化的原因

### 任务2：切片陷阱探索
创建 `slice_traps.go`

实现以下场景：
1. 切片共享底层数组的问题
2. 切片作为函数参数的行为
3. nil切片vs空切片的区别

思考：
- 什么时候会发生意外的数据修改？
- 如何避免这些问题？

### 任务3：实现动态数组
创建 `dynamic_array.go`

要求：
1. 实现一个简单的动态数组结构
2. 支持 Push、Pop、Get、Set 操作
3. 实现自定义的扩容策略
4. 编写基准测试，比较与内置切片的性能

提示：
- 考虑线程安全问题
- 思考何时需要缩容

### 任务4：切片算法练习
创建 `slice_algorithms.go`

实现以下算法：
1. 原地去重（不使用额外空间）
2. 旋转切片（左旋/右旋n个位置）
3. 查找两个切片的交集
4. 合并多个有序切片

要求：
- 注重算法效率
- 考虑边界条件

## 深入思考
1. 为什么Go选择切片而不是动态数组作为主要的序列类型？
2. 切片的设计如何体现了Go的哲学？
3. 在什么场景下应该使用数组而不是切片？

## 代码审查要点
- 是否正确理解了切片的引用语义？
- 是否注意了切片扩容带来的性能影响？
- 是否处理了边界条件？
- 代码是否遵循Go的惯用写法？

## 提交要求
1. 所有练习代码需要包含详细的打印输出
2. 每个函数都要有相应的测试用例
3. 在 `exercises/01-basics/day02/README.md` 中记录你的发现和理解
4. Git提交信息：`feat: complete day02 slice deep dive`

## 扩展阅读
- [Go Slices: usage and internals](https://blog.golang.org/slices)
- [Arrays, slices (and strings): The mechanics of 'append'](https://blog.golang.org/slices)

## 挑战任务（可选）
实现一个高性能的切片池（Slice Pool），用于复用切片，减少内存分配。

## 明日预告
Day 3: Map原理与实践 - 探索Go中的哈希表实现